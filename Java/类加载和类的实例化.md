## 类加载机制

[TOC]

#### 加载

加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程.

以盖房子为例，村里的 Tony 要盖个房子，那么按照流程他得先找个建筑师，跟他说想要设计一个房型，比如说“一房、一厅、四卫”。你或许已经听出来了，这里的房型相当于类，而建筑师，就相当于类加载器。 

##### 加载类的来源

- Java 编译器生成的 class 文件
- 程序内部直接生成
- 从网络中获取（例如网页中内嵌的小程序 Java applet）字节流。

```
这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。这就是我们日常开发中设计到的类。
```

##### 类加载器

- 系统加载器 ：启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代，加载存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）
- 扩展类加载器（extension class loader）：扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。  
- 应用加载器（application class loader）：应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 

除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。

##### Android中的类加载器

- BaseDexClassLoader:Android启动的时候,会加载一些常用的类
- PathClassLoader: 可以加载已安装的apk文件文件中的Activity,View
- DexClassLoader: 任意文件中的dex文件,因为它的构造中提供了一个path这个参数,但是在pathClassLoader中这个参数为空

所有的加载,均会走到DexPathList中的findClass中

##### 双亲委派机制机制

村里有许多建筑师，他们等级森严，但有着共同的祖师爷，叫启动类加载器（boot class loader）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。换句话说，祖师爷不喜欢像 Tony 这样的小角色来打扰他，所以谁也没有祖师爷的联系方式。

##### 双亲委派机制的必要性

- 确保类的唯一性: 判断两个类相同的标志是,是否是同一个类,并且是由同一个类加载器加载的,instanceOf函数
- 减少资源的使用,如果父类已经加载过了,那么子类就可以直接使用

#### 链接

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段

##### 验证

验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。通常来讲由Java虚拟机编译的字节码必然是符合Java虚拟加规范的

这就好比 Tony 需要将设计好的房型提交给市政部门审核。只有当审核通过，才能继续下面的建造工作。 

##### 准备

准备阶段的目的，则是为被加载类的静态字段分配内存。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。 

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。 

Java中所有的非私有实例方法，都算是虚方法。

##### 解析

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。 

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。 

解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。） 

#### 初始化

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。 

如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 `<clinit>`。 

##### 初始化时机

1. 当虚拟机启动时，初始化用户指定的主类； 
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类； 
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 
5. 子类的初始化会触发父类的初始化； 
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 
7. 使用反射 API 对某个类进行反射调用时，初始化这个类； 
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 
9. 通过数组定义来使用类的时候

##### 类的初始化和类的实例化差别

- 类的初始化: 为静态变量赋值,以及静态代码块中的代码,通过`<clint>`执行
- 类的实例化: 为实例变量分配内存,赋值

#### 使用

```java
public class Test {
    public static Test t1 = new Test();
    public static Test t2 = new Test();

    {
        System.out.println("构造块");
        showStaticMethod();
        if(t1!=null){
            t1.show();
        }
        System.out.println(number);
    }
    static {
        System.out.println("静态块");
    }

    private static int number=10+10;

    public static void showStaticMethod(){
        System.out.println("静态方法执行");
    }
    public  void show(){
        System.out.println("Foking");
    }
    public static void main(String[] args) {
        Test t = new Test();
    }
}

输出：
构造块
静态方法执行
0
构造块
静态方法执行
Foking
0
静态块
构造块
静态方法执行
Foking
20

```

将`Number`这个字段放置定义t1,t2之前

```java
public class Test {
    private static int number=10+10;
    public static Test t1 = new Test();
    public static Test t2 = new Test();

    {
        System.out.println("构造块");
        showStaticMethod();
        if(t1!=null){
            t1.show();
        }
        System.out.println(number);
    }
    static {
        System.out.println("静态块");
    }


    public static void showStaticMethod(){
        System.out.println("静态方法执行");
    }
    public  void show(){
        System.out.println("Foking");
    }
    public static void main(String[] args) {
        Test t = new Test();
    }
}
输出：
构造块
静态方法执行
20
构造块
静态方法执行
Foking
20
静态块
构造块
静态方法执行
Foking
20
```

- 静态代码块，静态成员变量只初始化一次。在类的初始化过程中执行！！！

- 静态代码和静态变量的的执行顺序，是按照代码中的自上而下的顺序执行

- 非静态代码块和非静态成员变量在实例化过程中被执行，每次实例化都会执行！！！

- **类的初始化和类的实例化，这两个过程是两个互相独立的，两个过程所要执行的任务也是分开的！！！**

- **类的初始化和类的实例化执行顺序也是不一定的，比如：类实例化完成时，类的初始化不一定已经完成了。在类初始化过程中，可以实例化本类！！！**

  ![](..\images\类加载.png)

#### 卸载

**由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。**Java虚拟机**自带的类加载器**包括**根类加载器**、**扩展类加载器**和**系统类加载器**。Java虚拟机本身会**始终引用**这些类加载器，而这些类加载器则会**始终引用**它们所加载的类的Class对象，因此这些Class对象**始终是可触及的**。**由用户自定义的类加载器加载的类是可以被卸载的。** 

[卸载机制](https://blog.csdn.net/chenleixing/article/details/47099771)

