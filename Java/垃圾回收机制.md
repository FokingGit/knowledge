#### 垃圾回收机制

Java中的垃圾回收机制是**标记回收法**

##### 标记

- 引用计数法: 为每个引用添加一个引用计数器,无法解决循环引用的问题
- 可达性分析算法:将一系列GCRoots作为初始对象的合集,然后从GcRoots出发,能够被引用到的对象添加到该合集中,不能被引用的到对像就是被认为是死亡对性,需要清理的

常用GCRoots:

1. 静态变量
2. 已开始但没有停止的线程
3. Java栈帧中的局部变量
4. JNI Handler

##### 回收

在清除的过程中,垃圾回收线程运行的时候,其他非垃圾回收线程均会停止,防止多线程引发的安全问题

- 清除的策略:分代收集

- 清除的方式

  - 清除,将死亡对性所占用的内存标记为空闲,并记录在一个空闲列表中,当需要新建对象的时候,从列表中分配内存

    缺点: 造成内存碎片不连续,会出现空闲内存很大,但是无法分配的情况

  - 压缩:把存活的对像压缩到起始位置,从而留下一段连续的内存空间,

    缺点: 压缩太耗性能

  - 拷贝:将内存分为两部分,分别用两个指针from和to指针来维护,并且只用from指针来分配内存,当垃圾回收器运行时将存活的对象由from指针指向的内存复制到to指针指向的内存,来解决内存碎片化的问题

    缺点: 堆空间内存的使用效率特别低

##### 分代回收算法

![](../images/分代回收.png)

1. Java虚拟机将堆内存分为**新生代**和**老年代**

2. 又将新生代的区域分为三块区域, eden区和两个survivors区(from指向和to指向 to指向的区域永远是空的).

3. 当我们new对象的时候,Java虚拟机会在eden区,开辟一块内存,这个过程需要进行同步操作(TLAB:每个线程可以向虚拟机申请一段连续的内存,作为线程私有)

4. **当eden区满之后会触发一次minor GC**,当发生Minor GC的时候,Eden区和from指向的survivors区中的存活对象均会被复制到to 指向的survivors区,然后交换from 和to 指针,继续保证to 指向的survivors区是空的;

5. Java虚拟机会记录每个对象被复制的次数,当复制的次数大于15次之后,该对象会被晋升到老年代,如果单个survivors区的内存大于50%,其中复制次数较多的对象也会被晋升到老年代;
   总的来说,在minor gc 过程使用了**标记-复制**的回收算法,理想情况下,在回收的过程中,eden区的数据基本被回收掉了.
6. minor gc的好处就是不用对整个堆进行回收,但是他会引发另外一个问题,如果老年代中可能持有新生代的引用,这种情况可以通过卡表的方式进行解决